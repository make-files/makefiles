MF_LANGUAGES += go

# Always run tests by default, even if other makefiles are included beforehand.
.DEFAULT_GOAL := test

# Build Go source files from protocol buffers definitions.
#
# Any files in underscore-prefixed directory names are ignored, as per the Go
# convention of using underscores to exclude files and directories from the
# build.
GENERATED_FILES += $(foreach f,$(PROTO_FILES:.proto=.pb.go),$(if $(findstring /_,/$f),,$f))
GENERATED_FILES += $(foreach f,$(PROTO_GRPC_FILES:.proto=_grpc.pb.go),$(if $(findstring /_,/$f),,$f))

# GO_ARCHIVE_FILES is a space separated list of additional files to include in
# the release archives. The compiled binaries are included by default.
GO_ARCHIVE_FILES +=

# GO_SOURCE_FILES is a space separated list of source files that are used by the
# build process.
GO_SOURCE_FILES += $(shell PATH="$(PATH)" git-find . -name '*.go' -not -regex '^_.*' -not -regex '.*\/_.*')

# GO_EMBEDDED_FILES is a space separated list of files that are embedded into
# the Go binary using the standard "embed" package.
GO_EMBEDDED_FILES +=

# Disable CGO by default.
# See https://golang.org/cmd/cgo
CGO_ENABLED ?= 0

# GO_APP_VERSION is a human-readable string describing the application version.
# If the "main" package has a variable named "version" it is set to this value
# at link time.
GO_APP_VERSION ?= $(SEMVER)

# GO_TEST_ARGS and GO_BENCHMARK_ARGS are arguments passed to "go test" command
# when running tests and benchmarks, respectively.
GO_TEST_ARGS      ?=
GO_BENCHMARK_ARGS ?=

# GO_DEBUG_ARGS and GO_RELEASE_ARGS are arguments passed to "go build" for the
# "debug" and "release" targets, respectively.
GO_DEBUG_ARGS   ?= -v -ldflags "-X main.version=$(GO_APP_VERSION)"
GO_RELEASE_ARGS ?= -v -ldflags "-X main.version=$(GO_APP_VERSION) -s -w"

# Build matrix configuration.
#
# GO_MATRIX is a whitespace separated set of operating systems and architectures.
GOHOSTOS   := $(shell go env GOHOSTOS)
GOHOSTARCH := $(shell go env GOHOSTARCH)
ifneq ($(GO_MATRIX_ARCH)$(GO_MATRIX_OS),)
GO_MATRIX  ?=
else
GO_MATRIX  ?= $(GOHOSTOS)/$(GOHOSTARCH)
endif

# GO_DEBUG_DIR is the relative path to the debug build directory for the current
# OS & architecture.
GO_DEBUG_DIR=artifacts/build/debug/$(GOHOSTOS)/$(GOHOSTARCH)

# GO_BUILDREQ is a space separated list of prerequisites needed to build the Go
# binaries.
GO_BUILD_REQ += go.mod

# GO_TEST_REQ is a space separated list of prerequisites needed to run tests.
GO_TEST_REQ += go.mod

# GO_BUILD_BEFORE_TEST indicates whether debug binaries should be built before
# running the tests.
#
# If it non-empty, all debug binaries for the current host are added to
# GO_TEST_REQ.
GO_BUILD_BEFORE_TEST ?=

# GO_RACE_DETECTION enables race detection in tests and debug builds.
GO_RACE_DETECTION ?= true

################################################################################

ifeq ($(GO_RACE_DETECTION),true)

# Enable the race detector in tests only if CGO is enabled via the environment.
#
# The Makefile doesn't exlicitly set CGO_ENABLED when running tests.
ifneq ($(shell go env CGO_ENABLED),0)
GO_TEST_ARGS  += -race
endif

# Enable the race detector in debug builds only if the user has explicitly
# enabled CGO either via the environment or the Makefile variable.
#
# The Makefile exlicitly sets CGO_ENABLED when building.
ifneq ($(CGO_ENABLED),0)
GO_DEBUG_ARGS += -race
endif

endif

# _GO_COMMAND_DIR and _GO_PLUGIN_DIR are the names of directories in the root of
# the project that contain subdirectories that are "main" packages that are to
# be built into executables and plugins, respectively.
_GO_COMMAND_DIR = cmd
_GO_PLUGIN_DIR = lib

# _GO_COMMAND_PACKAGES and _GO_PLUGIN_PACKAGES are lists of directory names that
# contain "main" packages that are to be built into executables and plugins,
# respectively.
_GO_COMMAND_PACKAGES = $(shell (find $(_GO_COMMAND_DIR) -type f -mindepth 2 -maxdepth 2 -name '*.go' -not -regex '.*\/_.*' | xargs -n1 dirname | sort -u | xargs -n1 basename) 2> /dev/null)
_GO_PLUGIN_PACKAGES  = $(shell (find $(_GO_PLUGIN_DIR)  -type f -mindepth 2 -maxdepth 2 -name '*.go' -not -regex '.*\/_.*' | xargs -n1 dirname | sort -u | xargs -n1 basename) 2> /dev/null)

# _GO_BUILDMODE_PLUGIN_PATTERNS is a list of patterns that are matched against
# the binary name to determine if we're building a command or a plugin.
_GO_BUILDMODE_PLUGIN_PATTERNS = %.so %.dll

# _GO_BINARIES_xxx is a list of binaries to produce in a build, including both
# executables and plugins.
_GO_BINARIES_NIX = $(_GO_COMMAND_PACKAGES) $(addsuffix .so,$(_GO_PLUGIN_PACKAGES))
_GO_BINARIES_WIN = $(addsuffix .exe,$(_GO_COMMAND_PACKAGES)) $(addsuffix .dll,$(_GO_PLUGIN_PACKAGES))

ifeq ($(GOHOSTOS),windows)
_GO_BINARIES_HOST = $(_GO_BINARIES_WIN)
else
_GO_BINARIES_HOST = $(_GO_BINARIES_NIX)
endif

# _GO_BUILD_PLATFORM_MATRIX_ALL is the union of GO_MATRIX (containing os/arch) and the
# cartesian product of all operating systems and architectures specified in
# GO_MATRIX_OS and GO_MATRIX_ARCH (which are now deprecated).
_GO_BUILD_PLATFORM_MATRIX_ALL  = $(sort $(foreach OS,$(GO_MATRIX_OS),$(foreach ARCH,$(GO_MATRIX_ARCH),$(OS)/$(ARCH))) $(GO_MATRIX))
_GO_BUILD_PLATFORM_MATRIX_NIX  = $(filter-out windows/%,$(_GO_BUILD_PLATFORM_MATRIX_ALL))
_GO_BUILD_PLATFORM_MATRIX_WIN  = $(filter windows/%,$(_GO_BUILD_PLATFORM_MATRIX_ALL))
_GO_BUILD_PLATFORM_MATRIX_HOST = $(GOHOSTOS)/$(GOHOSTARCH)

# Print deprecation warnings if GO_MATRIX_ARCH or GO_MATRIX_OS is used.
ifneq ($(GO_MATRIX_ARCH)$(GO_MATRIX_OS),)
$(warning GO_MATRIX_ARCH/GO_MATRIX_OS is deprecated, change to GO_MATRIX = $(_GO_BUILD_PLATFORM_MATRIX_ALL))
endif

# _GO_BUILD_MATRIX_xxx is the cartesian product of the platform matrix and the
# filenames of the binaries.
_GO_BUILD_MATRIX_NIX  = $(foreach P,$(_GO_BUILD_PLATFORM_MATRIX_NIX),$(addprefix $(P)/,$(_GO_BINARIES_NIX)))
_GO_BUILD_MATRIX_WIN  = $(foreach P,$(_GO_BUILD_PLATFORM_MATRIX_WIN),$(addprefix $(P)/,$(_GO_BINARIES_WIN)))
_GO_BUILD_MATRIX_HOST = $(foreach P,$(_GO_BUILD_PLATFORM_MATRIX_HOST),$(addprefix $(P)/,$(_GO_BINARIES_HOST)))

# _GO_DEBUG_TARGETS_xxx is the path to the binaries to produce for debug builds.
_GO_DEBUG_TARGETS_ALL    = $(addprefix artifacts/build/debug/,$(_GO_BUILD_MATRIX_NIX) $(_GO_BUILD_MATRIX_WIN))
_GO_DEBUG_TARGETS_HOST   = $(addprefix artifacts/build/debug/,$(_GO_BUILD_MATRIX_HOST))
.SECONDARY: $(_GO_DEBUG_TARGETS_ALL)

# _GO_DEBUG_TARGETS_xxx is the path to the binaries to produce for release builds.
_GO_RELEASE_TARGETS_ALL  = $(addprefix artifacts/build/release/,$(_GO_BUILD_MATRIX_NIX) $(_GO_BUILD_MATRIX_WIN))
_GO_RELEASE_TARGETS_HOST = $(addprefix artifacts/build/release/,$(_GO_BUILD_MATRIX_HOST))
.SECONDARY: $(_GO_RELEASE_TARGETS_HOST)

# Ensure that release binaries are built before attempting to build a Docker image.
DOCKER_BUILD_REQ += $(foreach PLATFORM,$(DOCKER_PLATFORMS),$(addprefix artifacts/build/release/$(PLATFORM)/,$(_GO_BINARIES_NIX)))

ifneq ($(GO_BUILD_BEFORE_TEST),)
GO_TEST_REQ += $(_GO_DEBUG_TARGETS_HOST)
endif

# GO_ARCHIVES is the list of archive files to be build, based on the build
# matrix.
GO_ARCHIVES ?= $(addprefix artifacts/archives/$(PROJECT_NAME)-$(GO_APP_VERSION)-,$(addsuffix .zip,$(subst /,-,$(_GO_BUILD_PLATFORM_MATRIX_ALL))))

################################################################################

# Treat any dependencies of the tests as secondary build targets so that they
# are not deleted after a successful test.
.SECONDARY: $(GO_TEST_REQ)

# test --- Executes all go tests in this module.
.PHONY: test
test:: $$(GENERATED_FILES) $(GO_TEST_REQ)
	go test $(GO_TEST_ARGS) ./...

# test-until-failure --- Execute all go tests in this module until they fail.
.PHONY: test-until-failure
test-until-failure:
	@counter=0; while go test -count=1 $(GO_TEST_ARGS) ./...; do \
		counter=$$(expr $$counter + 1); \
		echo "--- test run $$counter succeeded"; \
	done; echo "--- failed after $$counter successful run(s)"

# benchmark --- Executes all go benchmarks (but not tests) in this module.
.PHONY: benchmark
benchmark:: $$(GENERATED_FILES) $(GO_TEST_REQ)
	go test $(GO_BENCHMARK_ARGS) -bench=. -benchmem -run=^$$ ./...

# coverage --- Produces an HTML coverage report.
.PHONY: coverage
coverage:: artifacts/coverage/index.html

# coverage-open --- Opens the HTML coverage report in a browser.
.PHONY: coverage-open
coverage-open:: artifacts/coverage/index.html
	$(MF_BROWSER) "$<"

# precommit --- Perform tasks that need to be executed before committing. Stacks
# with the "precommit" target form the common makefile.
.PHONY: precommit
precommit:: debug release # artifacts/go/lint/golangci-lint.touch # Removed because of https://github.com/golangci/golangci-lint/issues/2374
	go fmt ./...
	go mod tidy
	make test

# ci --- Builds all binaries and a machine-readable coverage report. Stacks with
# the "ci" target from the common makefile.
.PHONY: ci
ci:: debug release artifacts/coverage/cover.out benchmark # artifacts/go/lint/golangci-lint.touch # Removed because of https://github.com/golangci/golangci-lint/issues/2374

# _clean --- Clears the Go test cache. Invoked by the "clean" target from the
# common makefile before the makefiles themselves are removed.
.PHONY: _clean
_clean::
	go clean -testcache

# build --- Builds debug binaries suitable for execution on this machine. It
# does not require the current OS and architecture to appear in the build
# matrix.
.PHONY: build
build: $(_GO_DEBUG_TARGETS_HOST)

# debug --- Builds debug binaries files for all platforms specified in the build
# matrix.
.PHONY: debug
debug: $(_GO_DEBUG_TARGETS_ALL)

# release --- Builds release binaries files for all platforms specified in the
# build matrix.
.PHONY: release
release: $(_GO_RELEASE_TARGETS_ALL)

# archives --- Builds zip archives containing the release binaries and an
# additional files specified in GO_ARCHIVE_FILES.
archives: $(GO_ARCHIVES)

# pre-intercept --- Removes the debug binaries for the current architecture
# before starting a Telepresence intercept, forcing them to be rebuild with
# CGO_ENABLED within the intercept.
.PHONY: pre-intercept
pre-intercept::
	rm -f $(_GO_DEBUG_TARGETS_HOST)

################################################################################

artifacts/coverage/index.html: artifacts/coverage/cover.out
	go tool cover -html="$<" -o "$@"

.PHONY: artifacts/coverage/cover.out # always rebuild
artifacts/coverage/cover.out: $$(GENERATED_FILES) $(GO_TEST_REQ)
	@mkdir -p $(@D)
	go test $(GO_TEST_ARGS) -covermode=atomic -coverprofile=$@ ./...
	$(MF_ROOT)/pkg/go/v1/bin/filter-coverage-report $@ $(GENERATED_FILES)

artifacts/build/%: $(GO_BUILD_REQ) $(GO_SOURCE_FILES) $$(GENERATED_FILES) $(GO_EMBEDDED_FILES)
	$(eval PARTS := $(subst /, ,$*))
	$(eval BUILD := $(word 1,$(PARTS)))
	$(eval OS    := $(word 2,$(PARTS)))
	$(eval ARCH  := $(patsubst arm_v%,arm,$(word 3,$(PARTS))))
	$(eval GOARM := $(patsubst arm_v%,%,$(filter arm_v%,$(word 3,$(PARTS)))))
	$(eval BIN   := $(word 4,$(PARTS)))
	$(eval MODE  := $(if $(filter $(_GO_BUILDMODE_PLUGIN_PATTERNS),$(BIN)),plugin,default))
	$(eval PKG   := $(if $(findstring plugin,$(MODE)),$(_GO_PLUGIN_DIR),$(_GO_COMMAND_DIR))/$(basename $(BIN)))
	$(eval ARGS  := $(if $(findstring debug,$(BUILD)),$(GO_DEBUG_ARGS),-trimpath $(GO_RELEASE_ARGS)))

	CGO_ENABLED=$(CGO_ENABLED) GOOS="$(OS)" GOARCH="$(ARCH)" GOARM="$(GOARM)" go build -tags=$(BUILD) -buildmode=$(MODE) $(ARGS) -o "$@" "./$(PKG)"

artifacts/archives/$(PROJECT_NAME)-$(GO_APP_VERSION)-windows-%.zip: $(GO_ARCHIVE_FILES) $$(addprefix artifacts/build/release/windows/$$*/,$(_GO_BINARIES_WIN))
	@mkdir -p "$(@D)"
	@rm -f "$@"
	zip --recurse-paths --junk-paths "$@" -- $^

artifacts/archives/$(PROJECT_NAME)-$(GO_APP_VERSION)-%.zip: $(GO_ARCHIVE_FILES) $$(addprefix artifacts/build/release/$$(subst -,/,$$*)/,$(_GO_BINARIES_NIX))
	@mkdir -p "$(@D)"
	@rm -f "$@"
	zip --recurse-paths --junk-paths "$@" -- $^

artifacts/go/bin/golangci-lint:
	$(MF_ROOT)/pkg/go/v1/bin/install-golangci-lint "$(MF_PROJECT_ROOT)/$(@D)"

artifacts/go/lint/golangci-lint.touch: artifacts/go/bin/golangci-lint $(GO_SOURCE_FILES)
	artifacts/go/bin/golangci-lint run --config $(MF_ROOT)/pkg/go/v1/etc/.golangci.yml ./...

	@mkdir -p "$(@D)"
	@touch "$@"
